<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>High Concurrency System Design: Complete Study Guide</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            line-height: 1.6;
            color: #e0e0e0;
            background: linear-gradient(135deg, #1a1a2e, #16213e, #0f3460);
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }

        .header {
            text-align: center;
            margin-bottom: 3rem;
            padding: 2rem 0;
        }

        .header h1 {
            font-size: 3rem;
            background: linear-gradient(45deg, #667eea, #764ba2, #f093fb);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 1rem;
        }

        .header p {
            font-size: 1.2rem;
            color: #b0b0b0;
            max-width: 600px;
            margin: 0 auto;
        }

        .progress-section {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 1.5rem;
            margin-bottom: 2rem;
            backdrop-filter: blur(10px);
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 0.5rem;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            border-radius: 4px;
            transition: width 0.3s ease;
            width: 0%;
        }

        .progress-text {
            text-align: center;
            font-size: 0.9rem;
            color: #b0b0b0;
        }

        .section {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            margin-bottom: 1.5rem;
            overflow: hidden;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }

        .section:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
        }

        .section-header {
            padding: 1.5rem;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(255, 255, 255, 0.03);
        }

        .section-title {
            font-size: 1.3rem;
            font-weight: 600;
            color: #fff;
        }

        .section-meta {
            display: flex;
            align-items: center;
            gap: 1rem;
            font-size: 0.9rem;
            color: #b0b0b0;
        }

        .expand-icon {
            font-size: 1.2rem;
            transition: transform 0.3s ease;
        }

        .section.expanded .expand-icon {
            transform: rotate(180deg);
        }

        .section-content {
            display: none;
            padding: 0 1.5rem;
        }

        .section.expanded .section-content {
            display: block;
            padding: 0 1.5rem 1.5rem;
        }

        .lesson {
            background: rgba(255, 255, 255, 0.03);
            border-radius: 10px;
            margin-bottom: 1rem;
            padding: 1.5rem;
            border-left: 4px solid transparent;
            transition: all 0.3s ease;
        }

        .lesson:hover {
            border-left-color: #667eea;
            background: rgba(255, 255, 255, 0.06);
        }

        .lesson-header {
            display: flex;
            align-items: center;
            margin-bottom: 1rem;
        }

        .lesson-checkbox {
            margin-right: 1rem;
            transform: scale(1.2);
        }

        .lesson-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: #fff;
            flex: 1;
        }

        .lesson-link {
            color: #667eea;
            text-decoration: none;
            font-size: 0.9rem;
            opacity: 0.8;
            transition: opacity 0.3s ease;
        }

        .lesson-link:hover {
            opacity: 1;
        }

        .lesson-content h3 {
            color: #667eea;
            margin: 1rem 0 0.5rem;
            font-size: 1rem;
        }

        .lesson-content ul {
            margin-left: 1rem;
            margin-bottom: 1rem;
        }

        .lesson-content li {
            margin-bottom: 0.3rem;
            color: #d0d0d0;
        }

        .key-concepts, .takeaways, .interview-tips {
            margin-bottom: 1rem;
        }

        .footer {
            text-align: center;
            margin-top: 3rem;
            padding: 2rem;
            color: #b0b0b0;
        }

        @media (max-width: 768px) {
            .container {
                padding: 1rem;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .section-header {
                padding: 1rem;
            }
            
            .section-meta {
                flex-direction: column;
                gap: 0.5rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ðŸš€ High Concurrency System Design</h1>
            <p>Complete English Study Guide - 40 Essential Lessons for System Design Mastery</p>
        </div>

        <div class="progress-section">
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <div class="progress-text" id="progressText">Progress: 0/40 lessons completed</div>
        </div>

        <!-- Section 1: Fundamentals -->
        <div class="section" data-section="fundamentals">
            <div class="section-header" onclick="toggleSection('fundamentals')">
                <div>
                    <div class="section-title">01. Fundamentals (6 lessons)</div>
                    <div class="section-meta">
                        <span>Design Methods â€¢ Architecture Layers â€¢ Performance â€¢ High Availability â€¢ Scalability</span>
                    </div>
                </div>
                <div class="expand-icon">â–¼</div>
            </div>
            <div class="section-content">
                <div class="lesson">
                    <div class="lesson-header">
                        <input type="checkbox" class="lesson-checkbox" onchange="updateProgress()">
                        <div class="lesson-title">High Concurrency Systems: Universal Design Methods</div>
                        <a href="https://zq99299.github.io/note-architect/hc/01/01.html" class="lesson-link" target="_blank">ðŸ”— Original</a>
                    </div>
                    <div class="lesson-content">
                        <h3>Key Concepts:</h3>
                        <ul>
                            <li><strong>Three Core Approaches:</strong> Scale-out (horizontal scaling), Caching, and Asynchronous Processing</li>
                            <li><strong>Scale-up vs Scale-out:</strong> Vertical scaling (better hardware) vs horizontal scaling (distributed systems)</li>
                            <li><strong>Moore's Law Impact:</strong> Hardware performance evolution and its limitations leading to multi-core solutions</li>
                            <li><strong>System Evolution:</strong> Gradual improvement driven by actual problems, not premature optimization</li>
                        </ul>
                        <h3>Main Takeaways:</h3>
                        <ul>
                            <li>High concurrency design is like flood control - use expansion (scale-out), flow optimization (caching), and buffering (async)</li>
                            <li>Start simple, then evolve architecture incrementally as traffic and requirements grow</li>
                            <li>Scale-out introduces complexity (fault tolerance, consistency, node management) but breaks single-machine limits</li>
                            <li>Each approach has trade-offs and should be applied based on specific system constraints and requirements</li>
                        </ul>
                        <h3>Interview Relevance:</h3>
                        <ul>
                            <li>Fundamental knowledge for system design questions</li>
                            <li>Demonstrates understanding of scalability trade-offs</li>
                            <li>Shows architectural evolution thinking</li>
                        </ul>
                    </div>
                </div>

                <div class="lesson">
                    <div class="lesson-header">
                        <input type="checkbox" class="lesson-checkbox" onchange="updateProgress()">
                        <div class="lesson-title">Architecture Layering: Why It's Essential</div>
                        <a href="https://zq99299.github.io/note-architect/hc/01/02.html" class="lesson-link" target="_blank">ðŸ”— Original</a>
                    </div>
                    <div class="lesson-content">
                        <h3>Key Concepts:</h3>
                        <ul>
                            <li><strong>Layered Architecture Patterns:</strong> MVC, Three-tier (Presentation/Logic/Data), OSI network model</li>
                            <li><strong>Alibaba's Enhanced Model:</strong> Terminal Display â†’ Open API â†’ Web â†’ Service â†’ Manager â†’ DAO â†’ External Services</li>
                            <li><strong>Manager Layer:</strong> Handles common business operations, caching strategies, and third-party service integration</li>
                            <li><strong>Clear Boundaries:</strong> Each layer has single responsibility with well-defined interfaces</li>
                        </ul>
                        <h3>Main Takeaways:</h3>
                        <ul>
                            <li>Layering enables specialization - different teams can focus on specific layers</li>
                            <li>Promotes reusability - well-designed layers can be reused across projects</li>
                            <li>Enables targeted horizontal scaling - scale specific layers based on bottlenecks</li>
                            <li>Data flow must be adjacent-layer only to maintain architectural integrity</li>
                            <li>Trade-off: increased complexity and potential performance overhead vs maintainability</li>
                        </ul>
                        <h3>Interview Relevance:</h3>
                        <ul>
                            <li>Shows understanding of software design principles (SRP, DRY, Open/Closed)</li>
                            <li>Critical for designing scalable systems</li>
                            <li>Demonstrates ability to manage complexity in large systems</li>
                        </ul>
                    </div>
                </div>

                <div class="lesson">
                    <div class="lesson-header">
                        <input type="checkbox" class="lesson-checkbox" onchange="updateProgress()">
                        <div class="lesson-title">System Design Goal 1: How to Improve System Performance</div>
                        <a href="https://zq99299.github.io/note-architect/hc/01/03.html" class="lesson-link" target="_blank">ðŸ”— Original</a>
                    </div>
                    <div class="lesson-content">
                        <h3>Key Concepts:</h3>
                        <ul>
                            <li><strong>Three High Goals:</strong> High Performance, High Availability, High Scalability</li>
                            <li><strong>Performance Metrics:</strong> Response time (avg, max, percentiles), throughput, concurrent users</li>
                            <li><strong>User Experience Thresholds:</strong> <200ms (imperceptible), <1s (acceptable), >1s (noticeable delay)</li>
                            <li><strong>Amdahl's Law:</strong> Speedup = 1/(1-p+p/s), where p is parallel portion, s is parallel processes</li>
                        </ul>
                        <h3>Main Takeaways:</h3>
                        <ul>
                            <li>Performance optimization must be problem-driven and data-supported</li>
                            <li>Follow 80/20 rule - use 20% effort to solve 80% of performance issues</li>
                            <li>Two optimization approaches: increase processing cores OR reduce response time</li>
                            <li>System has performance "breaking point" - beyond which adding resources hurts performance</li>
                            <li>CPU-intensive: optimize algorithms; I/O-intensive: optimize data access patterns</li>
                        </ul>
                        <h3>Interview Relevance:</h3>
                        <ul>
                            <li>Essential for performance optimization discussions</li>
                            <li>Shows understanding of system bottlenecks and monitoring</li>
                            <li>Demonstrates knowledge of parallelization limits</li>
                        </ul>
                    </div>
                </div>

                <div class="lesson">
                    <div class="lesson-header">
                        <input type="checkbox" class="lesson-checkbox" onchange="updateProgress()">
                        <div class="lesson-title">System Design Goal 2: High Availability Guaranteed</div>
                        <a href="https://zq99299.github.io/note-architect/hc/01/04.html" class="lesson-link" target="_blank">ðŸ”— Original</a>
                    </div>
                    <div class="lesson-content">
                        <h3>Key Concepts:</h3>
                        <ul>
                            <li><strong>Availability Levels:</strong> 99% (3.65 days/year downtime) to 99.999% (5.26 min/year downtime)</li>
                            <li><strong>Fault Types:</strong> Hardware failures, software bugs, human errors, natural disasters</li>
                            <li><strong>Redundancy Strategies:</strong> Hardware redundancy, service redundancy, data redundancy</li>
                            <li><strong>Failover Mechanisms:</strong> Active-passive, active-active, circuit breakers</li>
                        </ul>
                        <h3>Main Takeaways:</h3>
                        <ul>
                            <li>High availability requires eliminating single points of failure at every level</li>
                            <li>Redundancy adds cost and complexity - balance based on business requirements</li>
                            <li>Monitoring and alerting are crucial for rapid incident response</li>
                            <li>Graceful degradation better than complete failure</li>
                            <li>Regular disaster recovery drills ensure systems work when needed</li>
                        </ul>
                        <h3>Interview Relevance:</h3>
                        <ul>
                            <li>Critical for system reliability discussions</li>
                            <li>Shows understanding of fault tolerance patterns</li>
                            <li>Demonstrates risk assessment capabilities</li>
                        </ul>
                    </div>
                </div>

                <div class="lesson">
                    <div class="lesson-header">
                        <input type="checkbox" class="lesson-checkbox" onchange="updateProgress()">
                        <div class="lesson-title">System Design Goal 3: Scalable Architecture</div>
                        <a href="https://zq99299.github.io/note-architect/hc/01/05.html" class="lesson-link" target="_blank">ðŸ”— Original</a>
                    </div>
                    <div class="lesson-content">
                        <h3>Key Concepts:</h3>
                        <ul>
                            <li><strong>Scalability Dimensions:</strong> Load scalability, space scalability, geographic scalability</li>
                            <li><strong>Horizontal vs Vertical:</strong> Add more machines vs upgrade existing machines</li>
                            <li><strong>Stateless Design:</strong> Enable easy scaling by removing server-side session state</li>
                            <li><strong>Partitioning Strategies:</strong> Data partitioning, functional partitioning, service partitioning</li>
                        </ul>
                        <h3>Main Takeaways:</h3>
                        <ul>
                            <li>Design for scalability from the beginning - retrofitting is expensive</li>
                            <li>Stateless services scale more easily than stateful ones</li>
                            <li>Partition data and functionality to enable independent scaling</li>
                            <li>Load balancing and auto-scaling are essential scalability tools</li>
                            <li>Monitor scaling metrics to predict when scaling is needed</li>
                        </ul>
                        <h3>Interview Relevance:</h3>
                        <ul>
                            <li>Fundamental for system design questions</li>
                            <li>Shows ability to plan for growth</li>
                            <li>Demonstrates understanding of architectural flexibility</li>
                        </ul>
                    </div>
                </div>

                <div class="lesson">
                    <div class="lesson-header">
                        <input type="checkbox" class="lesson-checkbox" onchange="updateProgress()">
                        <div class="lesson-title">Interview Guide: System Design Fundamentals</div>
                        <a href="https://zq99299.github.io/note-architect/hc/01/06.html" class="lesson-link" target="_blank">ðŸ”— Original</a>
                    </div>
                    <div class="lesson-content">
                        <h3>Key Concepts:</h3>
                        <ul>
                            <li><strong>Interview Structure:</strong> Requirements gathering, capacity estimation, high-level design, detailed design</li>
                            <li><strong>Common Patterns:</strong> Load balancing, caching, database scaling, microservices</li>
                            <li><strong>Trade-offs:</strong> Consistency vs availability, latency vs throughput, cost vs performance</li>
                            <li><strong>Communication Skills:</strong> Think aloud, ask clarifying questions, consider alternatives</li>
                        </ul>
                        <h3>Main Takeaways:</h3>
                        <ul>
                            <li>Start with requirements and constraints before jumping to solutions</li>
                            <li>Estimate scale and capacity to drive design decisions</li>
                            <li>Discuss trade-offs explicitly and justify design choices</li>
                            <li>Consider operational concerns like monitoring, deployment, and maintenance</li>
                            <li>Practice drawing systems clearly and explaining architecture components</li>
                        </ul>
                        <h3>Interview Relevance:</h3>
                        <ul>
                            <li>Direct preparation for system design interviews</li>
                            <li>Framework for approaching complex technical problems</li>
                            <li>Communication and problem-solving demonstration</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>

        <!-- Section 2: Database Evolution -->
        <div class="section" data-section="database">
            <div class="section-header" onclick="toggleSection('database')">
                <div>
                    <div class="section-title">02. Database Evolution (5 lessons)</div>
                    <div class="section-meta">
                        <span>Connection Pooling â€¢ Read Replicas â€¢ Sharding â€¢ Distributed IDs â€¢ NoSQL</span>
                    </div>
                </div>
                <div class="expand-icon">â–¼</div>
            </div>
            <div class="section-content">
                <div class="lesson">
                    <div class="lesson-header">
                        <input type="checkbox" class="lesson-checkbox" onchange="updateProgress()">
                        <div class="lesson-title">Pooling Technology: Reducing Database Connection Overhead</div>
                        <a href="https://zq99299.github.io/note-architect/hc/02/01.html" class="lesson-link" target="_blank">ðŸ”— Original</a>
                    </div>
                    <div class="lesson-content">
                        <h3>Key Concepts:</h3>
                        <ul>
                            <li><strong>Connection Pool Management:</strong> Min/max connections, connection lifecycle, timeout handling</li>
                            <li><strong>Performance Impact:</strong> TCP handshake + MySQL auth ~4ms vs SQL execution ~1ms</li>
                            <li><strong>Thread Pool Pattern:</strong> coreThreadCount, maxThreadCount, queue management</li>
                            <li><strong>Pool Maintenance:</strong> Connection validation, stale connection cleanup, prewarming</li>
                        </ul>
                        <h3>Main Takeaways:</h3>
                        <ul>
                            <li>Pooling is space-for-time optimization - pre-create expensive resources</li>
                            <li>Connection creation is 4x slower than SQL execution - pooling gives 5x performance improvement</li>
                            <li>JDK ThreadPoolExecutor prioritizes queuing over thread creation (CPU-intensive optimization)</li>
                            <li>Web systems need IO-optimized thread pools (like Tomcat's) that prefer creating threads</li>
                            <li>Monitor queue depth - high backlog indicates undersized pools or performance bottlenecks</li>
                            <li>Avoid unbounded queues - they cause memory issues and mask performance problems</li>
                        </ul>
                        <h3>Interview Relevance:</h3>
                        <ul>
                            <li>Demonstrates understanding of resource management patterns</li>
                            <li>Shows knowledge of performance optimization techniques</li>
                            <li>Common follow-up questions about pool sizing and configuration</li>
                        </ul>
                    </div>
                </div>

                <div class="lesson">
                    <div class="lesson-header">
                        <input type="checkbox" class="lesson-checkbox" onchange="updateProgress()">
                        <div class="lesson-title">Database Optimization: Master-Slave Architecture</div>
                        <a href="https://zq99299.github.io/note-architect/hc/02/02.html" class="lesson-link" target="_blank">ðŸ”— Original</a>
                    </div>
                    <div class="lesson-content">
                        <h3>Key Concepts:</h3>
                        <ul>
                            <li><strong>Read/Write Separation:</strong> Route writes to master, reads to slaves</li>
                            <li><strong>Replication Mechanisms:</strong> Binary log replication, statement-based vs row-based</li>
                            <li><strong>Replication Lag:</strong> Delay between master write and slave update</li>
                            <li><strong>Failover Strategies:</strong> Master failover, slave promotion, virtual IP switching</li>
                        </ul>
                        <h3>Main Takeaways:</h3>
                        <ul>
                            <li>Read replicas scale read performance but introduce consistency challenges</li>
                            <li>Application must handle read-after-write scenarios carefully</li>
                            <li>Monitor replication lag and have fallback strategies for significant delays</li>
                            <li>Automatic failover requires careful coordination to prevent split-brain</li>
                            <li>Consider read preference strategies: master-only for critical reads</li>
                        </ul>
                        <h3>Interview Relevance:</h3>
                        <ul>
                            <li>Common database scaling pattern</li>
                            <li>Tests understanding of consistency vs availability trade-offs</li>
                            <li>Demonstrates knowledge of replication mechanisms</li>
                        </ul>
                    </div>
                </div>

                <div class="lesson">
                    <div class="lesson-header">
                        <input type="checkbox" class="lesson-checkbox" onchange="updateProgress()">
                        <div class="lesson-title">Database Scaling: Sharding Strategies</div>
                        <a href="https://zq99299.github.io/note-architect/hc/02/03.html" class="lesson-link" target="_blank">ðŸ”— Original</a>
                    </div>
                    <div class="lesson-content">
                        <h3>Key Concepts:</h3>
                        <ul>
                            <li><strong>Sharding Methods:</strong> Range-based, hash-based, directory-based</li>
                            <li><strong>Shard Key Selection:</strong> Even distribution, query pattern alignment, hotspot avoidance</li>
                            <li><strong>Cross-Shard Challenges:</strong> Transactions, joins, aggregations</li>
                            <li><strong>Resharding:</strong> Consistent hashing, virtual shards, online migration</li>
                        </ul>
                        <h3>Main Takeaways:</h3>
                        <ul>
                            <li>Sharding breaks relational model - design application logic accordingly</li>
                            <li>Choose shard keys carefully to balance load and support query patterns</li>
                            <li>Avoid hotspots through proper key design and monitoring</li>
                            <li>Plan for resharding from the beginning - it's inevitable at scale</li>
                            <li>Cross-shard operations are expensive - minimize through design</li>
                        </ul>
                        <h3>Interview Relevance:</h3>
                        <ul>
                            <li>Critical for large-scale database design</li>
                            <li>Tests understanding of distributed systems challenges</li>
                            <li>Shows ability to balance trade-offs</li>
                        </ul>
                    </div>
                </div>

                <div class="lesson">
                    <div class="lesson-header">
                        <input type="checkbox" class="lesson-checkbox" onchange="updateProgress()">
                        <div class="lesson-title">Distributed ID Generation Strategies</div>
                        <a href="https://zq99299.github.io/note-architect/hc/02/04.html" class="lesson-link" target="_blank">ðŸ”— Original</a>
                    </div>
                    <div class="lesson-content">
                        <h3>Key Concepts:</h3>
                        <ul>
                            <li><strong>ID Generation Methods:</strong> UUID, database sequences, Snowflake algorithm, leaf segment</li>
                            <li><strong>Requirements:</strong> Uniqueness, ordering, performance, availability</li>
                            <li><strong>Snowflake Format:</strong> Timestamp + machine ID + sequence number = 64-bit ID</li>
                            <li><strong>Clock Synchronization:</strong> NTP requirements, clock drift handling</li>
                        </ul>
                        <h3>Main Takeaways:</h3>
                        <ul>
                            <li>UUIDs provide uniqueness but lack ordering and consume more space</li>
                            <li>Database sequences are simple but create bottlenecks at scale</li>
                            <li>Snowflake provides ordering and high performance but requires clock synchronization</li>
                            <li>Consider ID requirements: uniqueness, ordering, performance, security</li>
                            <li>Plan for clock drift and machine ID conflicts in distributed systems</li>
                        </ul>
                        <h3>Interview Relevance:</h3>
                        <ul>
                            <li>Common distributed systems problem</li>
                            <li>Tests understanding of trade-offs between different approaches</li>
                            <li>Demonstrates knowledge of distributed system challenges</li>
                        </ul>
                    </div>
                </div>

                <div class="lesson">
                    <div class="lesson-header">
                        <input type="checkbox" class="lesson-checkbox" onchange="updateProgress()">
                        <div class="lesson-title">NoSQL Database Selection and Integration</div>
                        <a href="https://zq99299.github.io/note-architect/hc/02/05.html" class="lesson-link" target="_blank">ðŸ”— Original</a>
                    </div>
                    <div class="lesson-content">
                        <h3>Key Concepts:</h3>
                        <ul>
                            <li><strong>NoSQL Types:</strong> Document (MongoDB), Key-Value (Redis), Column (Cassandra), Graph (Neo4j)</li>
                            <li><strong>CAP Theorem:</strong> Consistency, Availability, Partition tolerance trade-offs</li>
                            <li><strong>Use Case Matching:</strong> Document for flexibility, Key-value for performance, Column for analytics</li>
                            <li><strong>Migration Strategies:</strong> Dual writes, change data capture, gradual cutover</li>
                        </ul>
                        <h3>Main Takeaways:</h3>
                        <ul>
                            <li>NoSQL databases sacrifice ACID for scalability and flexibility</li>
                            <li>Choose NoSQL type based on data structure and access patterns</li>
                            <li>Polyglot persistence: use different databases for different purposes</li>
                            <li>Consider operational complexity when adopting NoSQL</li>
                            <li>Plan migration carefully to avoid data inconsistency</li>
                        </ul>
                        <h3>Interview Relevance:</h3>
                        <ul>
                            <li>Demonstrates knowledge of database ecosystem</li>
                            <li>Shows understanding of when to use different technologies</li>
                            <li>Tests ability to balance consistency and scalability</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>

        <!-- Section 3: Caching -->
        <div class="section" data-section="caching">
            <div class="section-header" onclick="toggleSection('caching')">
                <div>
                    <div class="section-title">03. Caching (6 lessons)</div>
                    <div class="section-meta">
                        <span>Cache Strategies â€¢ HA Caching â€¢ Cache Penetration â€¢ CDN â€¢ Data Migration</span>
                    </div>
                </div>
                <div class="expand-icon">â–¼</div>
            </div>
            <div class="section-content">
                <div class="lesson">
                    <div class="lesson-header">
                        <input type="checkbox" class="lesson-checkbox" onchange="updateProgress()">
                        <div class="lesson-title">Cache: Accelerating Dynamic Data Queries</div>
                        <a href="https://zq99299.github.io/note-architect/hc/03/01.html" class="lesson-link" target="_blank">ðŸ”— Original</a>
                    </div>
                    <div class="lesson-content">
                        <h3>Key Concepts:</h3>
                        <ul>
                            <li><strong>Cache Types:</strong> Static cache (pre-rendered pages), Distributed cache (Redis/Memcached), Local cache (in-process)</li>
                            <li><strong>Hardware Performance:</strong> Memory ~100ns, Disk seek ~10ms (100,000x difference)</li>
                            <li><strong>Cache Patterns:</strong> Cache-aside, write-through, write-behind, refresh-ahead</li>
                            <li><strong>Hot Spot Handling:</strong> Local cache for extreme hot data to protect distributed cache</li>
                        </ul>
                        <h3>Main Takeaways:</h3>
                        <ul>
                            <li>Cache is any intermediate storage that reduces response time</li>
                            <li>Memory vs disk performance difference drives caching effectiveness</li>
                            <li>Multi-level caching: static (CDN) â†’ local cache â†’ distributed cache â†’ database</li>
                            <li>Cache works best for read-heavy workloads with hot data (80/20 rule)</li>
                            <li>Local cache handles extreme hotspots but requires careful expiration management</li>
                            <li>Trade-offs: performance gain vs complexity, memory usage, data consistency</li>
                        </ul>
                        <h3>Interview Relevance:</h3>
                        <ul>
                            <li>Fundamental caching concepts for system design</li>
                            <li>Shows understanding of performance optimization strategies</li>
                            <li>Common follow-up questions about cache patterns and consistency</li>
                        </ul>
                    </div>
                </div>

                <div class="lesson">
                    <div class="lesson-header">
                        <input type="checkbox" class="lesson-checkbox" onchange="updateProgress()">
                        <div class="lesson-title">Cache High Availability: Strategies and Patterns</div>
                        <a href="https://zq99299.github.io/note-architect/hc/03/02.html" class="lesson-link" target="_blank">ðŸ”— Original</a>
                    </div>
                    <div class="lesson-content">
                        <h3>Key Concepts:</h3>
                        <ul>
                            <li><strong>Replication Strategies:</strong> Master-slave, master-master, consistent hashing</li>
                            <li><strong>Failover Patterns:</strong> Client-side failover, proxy-based failover, Sentinel monitoring</li>
                            <li><strong>Data Consistency:</strong> Eventual consistency, read-your-writes, monotonic reads</li>
                            <li><strong>Split-brain Prevention:</strong> Quorum systems, witness servers, network partitioning</li>
                        </ul>
                        <h3>Main Takeaways:</h3>
                        <ul>
                            <li>Cache failures can cascade to database overload - plan redundancy carefully</li>
                            <li>Choose consistency model based on application requirements</li>
                            <li>Implement graceful degradation when cache is unavailable</li>
                            <li>Monitor cache hit rates and latency to detect issues early</li>
                            <li>Consider cache warming strategies after failures</li>
                        </ul>
                        <h3>Interview Relevance:</h3>
                        <ul>
                            <li>Tests understanding of distributed system failure modes</li>
                            <li>Shows knowledge of high availability patterns</li>
                            <li>Demonstrates ability to design resilient systems</li>
                        </ul>
                    </div>
                </div>

                <div class="lesson">
                    <div class="lesson-header">
                        <input type="checkbox" class="lesson-checkbox" onchange="updateProgress()">
                        <div class="lesson-title">Cache Penetration, Avalanche, and Hotspot Issues</div>
                        <a href="https://zq99299.github.io/note-architect/hc/03/03.html" class="lesson-link" target="_blank">ðŸ”— Original</a>
                    </div>
                    <div class="lesson-content">
                        <h3>Key Concepts:</h3>
                        <ul>
                            <li><strong>Cache Penetration:</strong> Queries for non-existent data bypass cache, hitting database</li>
                            <li><strong>Cache Avalanche:</strong> Multiple cache entries expire simultaneously, causing traffic spike</li>
                            <li><strong>Cache Hotspot:</strong> Uneven data access concentrates load on specific cache nodes</li>
                            <li><strong>Mitigation Strategies:</strong> Bloom filters, null value caching, random TTL, local cache</li>
                        </ul>
                        <h3>Main Takeaways:</h3>
                        <ul>
                            <li>Use Bloom filters to prevent penetration attacks on non-existent data</li>
                            <li>Cache null/empty results with short TTL to reduce database hits</li>
                            <li>Add random jitter to TTL values to prevent synchronized expiration</li>
                            <li>Use local cache to absorb hotspot traffic before hitting distributed cache</li>
                            <li>Monitor access patterns to detect and respond to hotspots quickly</li>
                        </ul>
                        <h3>Interview Relevance:</h3>
                        <ul>
                            <li>Common cache-related problems in high-traffic systems</li>
                            <li>Tests problem-solving skills for distributed system issues</li>
                            <li>Demonstrates understanding of attack vectors and defenses</li>
                        </ul>
                    </div>
                </div>

                <div class="lesson">
                    <div class="lesson-header">
                        <input type="checkbox" class="lesson-checkbox" onchange="updateProgress()">
                        <div class="lesson-title">CDN: Geographic Content Distribution</div>
                        <a href="https://zq99299.github.io/note-architect/hc/03/04.html" class="lesson-link" target="_blank">ðŸ”— Original</a>
                    </div>
                    <div class="lesson-content">
                        <h3>Key Concepts:</h3>
                        <ul>
                            <li><strong>CDN Architecture:</strong> Edge servers, origin servers, DNS routing, geographic distribution</li>
                            <li><strong>Content Types:</strong> Static assets, dynamic content, streaming media</li>
                            <li><strong>Caching Strategies:</strong> TTL-based, origin validation, cache purging</li>
                            <li><strong>Performance Benefits:</strong> Reduced latency, bandwidth savings, origin server protection</li>
                        </ul>
                        <h3>Main Takeaways:</h3>
                        <ul>
                            <li>CDN provides geographic proximity to reduce network latency</li>
                            <li>Effective for static content and cacheable dynamic content</li>
                            <li>Consider cache invalidation strategy for frequently updated content</li>
                            <li>Monitor CDN hit rates and geographic performance</li>
                            <li>Balance cost vs performance when selecting CDN coverage</li>
                        </ul>
                        <h3>Interview Relevance:</h3>
                        <ul>
                            <li>Important for global system design questions</li>
                            <li>Shows understanding of network optimization</li>
                            <li>Demonstrates knowledge of content delivery strategies</li>
                        </ul>
                    </div>
                </div>

                <div class="lesson">
                    <div class="lesson-header">
                        <input type="checkbox" class="lesson-checkbox" onchange="updateProgress()">
                        <div class="lesson-title">Cache Data Migration and Consistency</div>
                        <a href="https://zq99299.github.io/note-architect/hc/03/05.html" class="lesson-link" target="_blank">ðŸ”— Original</a>
                    </div>
                    <div class="lesson-content">
                        <h3>Key Concepts:</h3>
                        <ul>
                            <li><strong>Migration Strategies:</strong> Blue-green deployment, canary releases, gradual cutover</li>
                            <li><strong>Consistency Patterns:</strong> Write-through, write-behind, cache-aside</li>
                            <li><strong>Data Synchronization:</strong> Change data capture, event-driven updates, batch sync</li>
                            <li><strong>Rollback Plans:</strong> Data backup, traffic routing, rollback procedures</li>
                        </ul>
                        <h3>Main Takeaways:</h3>
                        <ul>
                            <li>Plan cache migrations carefully to avoid data loss or inconsistency</li>
                            <li>Use dual-write patterns during migration to maintain consistency</li>
                            <li>Monitor data integrity throughout migration process</li>
                            <li>Have rollback procedures ready in case of migration issues</li>
                            <li>Consider downtime tolerance when choosing migration strategy</li>
                        </ul>
                        <h3>Interview Relevance:</h3>
                        <ul>
                            <li>Tests understanding of data migration challenges</li>
                            <li>Shows operational thinking and risk management</li>
                            <li>Demonstrates knowledge of consistency guarantees</li>
                        </ul>
                    </div>
                </div>

                <div class="lesson">
                    <div class="lesson-header">
                        <input type="checkbox" class="lesson-checkbox" onchange="updateProgress()">
                        <div class="lesson-title">Cache Design Patterns and Best Practices</div>
                        <a href="https://zq99299.github.io/note-architect/hc/03/06.html" class="lesson-link" target="_blank">ðŸ”— Original</a>
                    </div>
                    <div class="lesson-content">
                        <h3>Key Concepts:</h3>
                        <ul>
                            <li><strong>Cache Patterns:</strong> Cache-aside, read-through, write-through, write-behind</li>
                            <li><strong>Eviction Policies:</strong> LRU, LFU, FIFO, TTL-based expiration</li>
                            <li><strong>Cache Sizing:</strong> Memory allocation, hit ratio optimization, cost considerations</li>
                            <li><strong>Monitoring Metrics:</strong> Hit ratio, latency, throughput, error rates</li>
                        </ul>
                        <h3>Main Takeaways:</h3>
                        <ul>
                            <li>Choose cache patterns based on consistency and performance requirements</li>
                            <li>Size cache based on working set and memory constraints</li>
                            <li>Monitor cache performance metrics to detect issues early</li>
                            <li>Implement proper error handling for cache failures</li>
                            <li>Document cache behavior for team understanding</li>
                        </ul>
                        <h3>Interview Relevance:</h3>
                        <ul>
                            <li>Comprehensive understanding of caching strategies</li>
                            <li>Shows ability to make informed design decisions</li>
                            <li>Demonstrates operational awareness</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>

        <!-- Sections 4-7 will be added with remaining lesson content -->
        <!-- For now, showing structure with placeholders -->
        
        <!-- Section 4: Message Queues -->
        <div class="section" data-section="messagequeues">
            <div class="section-header" onclick="toggleSection('messagequeues')">
                <div>
                    <div class="section-title">04. Message Queues (5 lessons)</div>
                    <div class="section-meta">
                        <span>Traffic Spikes â€¢ Exactly-Once Delivery â€¢ Latency Reduction â€¢ Interview Tips</span>
                    </div>
                </div>
                <div class="expand-icon">â–¼</div>
            </div>
            <div class="section-content">
                <div class="lesson">
                    <div class="lesson-header">
                        <input type="checkbox" class="lesson-checkbox" onchange="updateProgress()">
                        <div class="lesson-title">Message Queues: Handling 10K+ Orders Per Second in Flash Sales</div>
                        <a href="https://zq99299.github.io/note-architect/hc/04/01.html" class="lesson-link" target="_blank">ðŸ”— Original</a>
                    </div>
                    <div class="lesson-content">
                        <h3>Key Concepts:</h3>
                        <ul>
                            <li><strong>Peak Traffic Management:</strong> Flash sales create massive, short-duration write spikes (10K+ orders/second for 10-15 seconds)</li>
                            <li><strong>Queue as Buffer:</strong> Temporary storage container to balance speed differences between fast/slow systems (like ministers waiting at palace gates)</li>
                            <li><strong>Three Core Functions:</strong> Peak shaving, asynchronous processing, and system decoupling</li>
                            <li><strong>Processing Strategy:</strong> Background consumers with limited concurrency to protect downstream databases</li>
                        </ul>
                        <h3>Main Takeaways:</h3>
                        <ul>
                            <li>Peak shaving prevents database overload by queuing requests and processing at sustainable rate</li>
                            <li>Async processing separates critical (order creation) from non-critical (coupons, points) operations</li>
                            <li>Decoupling enables independent system evolution and fault isolation</li>
                            <li>Flash sales benefit: user tolerance for short delays in exchange for system stability</li>
                            <li>Capacity planning: 1000 items Ã— 500ms processing = 500s total. With 10 consumers = 50s delay (acceptable)</li>
                            <li>Monitor queue depth closely - high backlog indicates undersized consumers or bottlenecks</li>
                        </ul>
                        <h3>Interview Relevance:</h3>
                        <ul>
                            <li>Classic system design pattern for handling traffic spikes</li>
                            <li>Demonstrates understanding of async processing benefits and trade-offs</li>
                            <li>Shows capacity planning and performance estimation skills</li>
                        </ul>
                    </div>
                </div>

                <div class="lesson">
                    <div class="lesson-header">
                        <input type="checkbox" class="lesson-checkbox" onchange="updateProgress()">
                        <div class="lesson-title">Message Reliability: Ensuring Exactly-Once Delivery</div>
                        <a href="https://zq99299.github.io/note-architect/hc/04/02.html" class="lesson-link" target="_blank">ðŸ”— Original</a>
                    </div>
                    <div class="lesson-content">
                        <h3>Key Concepts:</h3>
                        <ul>
                            <li><strong>Message Guarantees:</strong> At-most-once, at-least-once, exactly-once delivery semantics</li>
                            <li><strong>Idempotency:</strong> Making operations safe to retry without side effects</li>
                            <li><strong>Deduplication:</strong> Client-generated unique IDs and server-side duplicate detection</li>
                            <li><strong>Transactional Outbox:</strong> Database + message queue consistency patterns</li>
                        </ul>
                        <h3>Main Takeaways:</h3>
                        <ul>
                            <li>Exactly-once delivery is hard - often implement idempotent consumers instead</li>
                            <li>Use unique request IDs for deduplication across retries</li>
                            <li>Implement transactional outbox pattern for database/queue consistency</li>
                            <li>Consider compensation actions for complex distributed transactions</li>
                            <li>Monitor duplicate message rates and processing failures</li>
                        </ul>
                        <h3>Interview Relevance:</h3>
                        <ul>
                            <li>Core distributed systems reliability concept</li>
                            <li>Tests understanding of consistency guarantees</li>
                            <li>Demonstrates knowledge of practical reliability patterns</li>
                        </ul>
                    </div>
                </div>

                <div class="lesson">
                    <div class="lesson-header">
                        <input type="checkbox" class="lesson-checkbox" onchange="updateProgress()">
                        <div class="lesson-title">Low-Latency Messaging: Reducing Message Processing Delay</div>
                        <a href="https://zq99299.github.io/note-architect/hc/04/03.html" class="lesson-link" target="_blank">ðŸ”— Original</a>
                    </div>
                    <div class="lesson-content">
                        <h3>Key Concepts:</h3>
                        <ul>
                            <li><strong>Push vs Pull:</strong> Consumer notification strategies and their latency implications</li>
                            <li><strong>Batching Trade-offs:</strong> Throughput vs latency when processing messages</li>
                            <li><strong>Prefetching:</strong> Consumer-side message buffering to reduce round trips</li>
                            <li><strong>Partitioning:</strong> Parallel processing and ordering guarantees</li>
                        </ul>
                        <h3>Main Takeaways:</h3>
                        <ul>
                            <li>Push models reduce latency but require careful backpressure handling</li>
                            <li>Batch size affects both throughput and latency - tune based on requirements</li>
                            <li>Prefetching improves throughput but increases memory usage</li>
                            <li>Partitioning enables parallel processing while maintaining message ordering</li>
                            <li>Consider queue depth, consumer count, and message processing time in latency calculations</li>
                        </ul>
                        <h3>Interview Relevance:</h3>
                        <ul>
                            <li>Shows understanding of performance optimization in messaging systems</li>
                            <li>Demonstrates knowledge of throughput vs latency trade-offs</li>
                            <li>Important for real-time system design questions</li>
                        </ul>
                    </div>
                </div>

                <div class="lesson">
                    <div class="lesson-header">
                        <input type="checkbox" class="lesson-checkbox" onchange="updateProgress()">
                        <div class="lesson-title">Message Queue Interview Tips and Best Practices</div>
                        <a href="https://zq99299.github.io/note-architect/hc/04/04.html" class="lesson-link" target="_blank">ðŸ”— Original</a>
                    </div>
                    <div class="lesson-content">
                        <h3>Key Concepts:</h3>
                        <ul>
                            <li><strong>Technology Selection:</strong> RabbitMQ vs Kafka vs RocketMQ vs Pulsar comparison</li>
                            <li><strong>Common Patterns:</strong> Pub/Sub, work queues, request/reply, routing patterns</li>
                            <li><strong>Operational Concerns:</strong> Monitoring, alerting, capacity planning, disaster recovery</li>
                            <li><strong>Integration Patterns:</strong> Event sourcing, CQRS, saga patterns with messaging</li>
                        </ul>
                        <h3>Main Takeaways:</h3>
                        <ul>
                            <li>Choose message queue technology based on throughput, ordering, and durability requirements</li>
                            <li>Design for message schema evolution and backward compatibility</li>
                            <li>Implement proper error handling, dead letter queues, and poison message handling</li>
                            <li>Monitor queue depth, consumer lag, processing rates, and error rates</li>
                            <li>Consider message ordering, partitioning strategies, and consumer group management</li>
                        </ul>
                        <h3>Interview Relevance:</h3>
                        <ul>
                            <li>Comprehensive messaging system knowledge</li>
                            <li>Technology comparison and selection criteria</li>
                            <li>Operational maturity and system reliability focus</li>
                        </ul>
                    </div>
                </div>

                <div class="lesson">
                    <div class="lesson-header">
                        <input type="checkbox" class="lesson-checkbox" onchange="updateProgress()">
                        <div class="lesson-title">Mid-Term Quiz: Message Queue Design Patterns</div>
                        <a href="https://zq99299.github.io/note-architect/hc/04/05.html" class="lesson-link" target="_blank">ðŸ”— Original</a>
                    </div>
                    <div class="lesson-content">
                        <h3>Key Concepts:</h3>
                        <ul>
                            <li><strong>Pattern Recognition:</strong> Identifying when to use different message queue patterns</li>
                            <li><strong>Design Trade-offs:</strong> Consistency vs availability, throughput vs latency</li>
                            <li><strong>Failure Scenarios:</strong> Network partitions, consumer failures, broker failures</li>
                            <li><strong>Scaling Strategies:</strong> Horizontal scaling, partitioning, consumer group management</li>
                        </ul>
                        <h3>Main Takeaways:</h3>
                        <ul>
                            <li>Practice identifying appropriate messaging patterns for different scenarios</li>
                            <li>Understand failure modes and recovery strategies</li>
                            <li>Consider operational complexity when choosing messaging solutions</li>
                            <li>Balance performance, reliability, and cost in message queue design</li>
                        </ul>
                        <h3>Interview Relevance:</h3>
                        <ul>
                            <li>Tests comprehensive understanding of message queue concepts</li>
                            <li>Practice for system design interview scenarios</li>
                            <li>Demonstrates ability to evaluate trade-offs and make design decisions</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>

        <!-- Section 5: Distributed Services -->
        <div class="section" data-section="distributed">
            <div class="section-header" onclick="toggleSection('distributed')">
                <div>
                    <div class="section-title">05. Distributed Services (9 lessons)</div>
                    <div class="section-meta">
                        <span>Microservices â€¢ RPC â€¢ Service Discovery â€¢ Load Balancing â€¢ API Gateway</span>
                    </div>
                </div>
                <div class="expand-icon">â–¼</div>
            </div>
            <div class="section-content">
                <div class="lesson">
                    <div class="lesson-header">
                        <input type="checkbox" class="lesson-checkbox" onchange="updateProgress()">
                        <div class="lesson-title">System Architecture: When to Split Services (10K QPS Case Study)</div>
                        <a href="https://zq99299.github.io/note-architect/hc/05/01.html" class="lesson-link" target="_blank">ðŸ”— Original</a>
                    </div>
                    <div class="lesson-content">
                        <h3>Key Concepts:</h3>
                        <ul>
                            <li><strong>Monolith Pain Points:</strong> Database connection exhaustion, development team coordination issues, deployment complexity</li>
                            <li><strong>Database Bottlenecks:</strong> Connection pool limits (e.g., 8000 max connections, 3400 peak usage across all services)</li>
                            <li><strong>Team Scaling Issues:</strong> Communication cost O(nÂ²) for n developers, code conflicts, coupled deployments</li>
                            <li><strong>Microservice Triggers:</strong> Resource constraints, team efficiency, operational overhead - not just QPS</li>
                        </ul>
                        <h3>Main Takeaways:</h3>
                        <ul>
                            <li>QPS alone doesn't determine when to split - focus on actual bottlenecks and team productivity</li>
                            <li>Database connection exhaustion is a common monolith scaling limit</li>
                            <li>Split services by business domain (user service, order service) for better resource control</li>
                            <li>Extract common utilities (geolocation service) to avoid code duplication</li>
                            <li>Each service gets dedicated connections, clearer ownership, faster deployment</li>
                            <li>Team structure should match service boundaries (Conway's Law)</li>
                        </ul>
                        <h3>Interview Relevance:</h3>
                        <ul>
                            <li>Classic monolith-to-microservices evolution question</li>
                            <li>Shows understanding of scalability bottlenecks beyond just traffic</li>
                            <li>Demonstrates knowledge of organizational and technical factors in architecture decisions</li>
                        </ul>
                    </div>
                </div>

                <div class="lesson">
                    <div class="lesson-header">
                        <input type="checkbox" class="lesson-checkbox" onchange="updateProgress()">
                        <div class="lesson-title">Microservices: Design Principles and Challenges</div>
                        <a href="https://zq99299.github.io/note-architect/hc/05/02.html" class="lesson-link" target="_blank">ðŸ”— Original</a>
                    </div>
                    <div class="lesson-content">
                        <h3>Key Concepts:</h3>
                        <ul>
                            <li><strong>Service Boundaries:</strong> Business capability alignment, single responsibility principle</li>
                            <li><strong>Communication Patterns:</strong> Synchronous RPC, asynchronous messaging, event-driven architecture</li>
                            <li><strong>Data Management:</strong> Database per service, eventual consistency, distributed transactions</li>
                            <li><strong>Operational Complexity:</strong> Service discovery, configuration management, monitoring, debugging</li>
                        </ul>
                        <h3>Main Takeaways:</h3>
                        <ul>
                            <li>Design services around business capabilities, not technical layers</li>
                            <li>Embrace decentralized data management and eventual consistency</li>
                            <li>Implement proper service contracts and API versioning</li>
                            <li>Invest heavily in automation: CI/CD, testing, monitoring, deployment</li>
                            <li>Plan for distributed system failures: circuit breakers, bulkheads, timeouts</li>
                            <li>Consider organizational impact: team structure, communication overhead</li>
                        </ul>
                        <h3>Interview Relevance:</h3>
                        <ul>
                            <li>Core microservices design principles</li>
                            <li>Understanding of distributed system complexity</li>
                            <li>Operational maturity and DevOps considerations</li>
                        </ul>
                    </div>
                </div>

                <div class="lesson">
                    <div class="lesson-header">
                        <input type="checkbox" class="lesson-checkbox" onchange="updateProgress()">
                        <div class="lesson-title">RPC Framework: High-Performance Remote Procedure Calls</div>
                        <a href="https://zq99299.github.io/note-architect/hc/05/03.html" class="lesson-link" target="_blank">ðŸ”— Original</a>
                    </div>
                    <div class="lesson-content">
                        <h3>Key Concepts:</h3>
                        <ul>
                            <li><strong>RPC Components:</strong> Client stub, server skeleton, serialization, network transport</li>
                            <li><strong>Serialization:</strong> Protocol Buffers, Avro, JSON - performance vs compatibility trade-offs</li>
                            <li><strong>Transport Protocols:</strong> HTTP/2, TCP, UDP - reliability vs performance considerations</li>
                            <li><strong>Load Balancing:</strong> Client-side vs server-side, health checking, failover strategies</li>
                        </ul>
                        <h3>Main Takeaways:</h3>
                        <ul>
                            <li>Choose serialization format based on performance requirements and schema evolution needs</li>
                            <li>Implement proper error handling, timeouts, and retry policies</li>
                            <li>Design for backward compatibility in API evolution</li>
                            <li>Consider connection pooling and multiplexing for performance</li>
                            <li>Implement comprehensive observability: metrics, tracing, logging</li>
                        </ul>
                        <h3>Interview Relevance:</h3>
                        <ul>
                            <li>Technical deep dive into RPC implementation details</li>
                            <li>Understanding of performance optimization techniques</li>
                            <li>Demonstrates knowledge of distributed communication patterns</li>
                        </ul>
                    </div>
                </div>

                <div class="lesson">
                    <div class="lesson-header">
                        <input type="checkbox" class="lesson-checkbox" onchange="updateProgress()">
                        <div class="lesson-title">Service Discovery: Dynamic Service Location</div>
                        <a href="https://zq99299.github.io/note-architect/hc/05/04.html" class="lesson-link" target="_blank">ðŸ”— Original</a>
                    </div>
                    <div class="lesson-content">
                        <h3>Key Concepts:</h3>
                        <ul>
                            <li><strong>Discovery Patterns:</strong> Client-side discovery, server-side discovery, service registry</li>
                            <li><strong>Registration:</strong> Self-registration vs third-party registration</li>
                            <li><strong>Health Checking:</strong> Active health checks, passive failure detection</li>
                            <li><strong>Consistency Models:</strong> Strong consistency vs eventual consistency in service registries</li>
                        </ul>
                        <h3>Main Takeaways:</h3>
                        <ul>
                            <li>Service discovery is critical for dynamic service environments</li>
                            <li>Choose consistency model based on availability requirements</li>
                            <li>Implement robust health checking to avoid routing to failed instances</li>
                            <li>Consider caching strategies for performance and resilience</li>
                            <li>Plan for service registry failures and split-brain scenarios</li>
                        </ul>
                        <h3>Interview Relevance:</h3>
                        <ul>
                            <li>Essential microservices infrastructure component</li>
                            <li>Tests understanding of distributed system coordination</li>
                            <li>Shows knowledge of availability vs consistency trade-offs</li>
                        </ul>
                    </div>
                </div>

                <div class="lesson">
                    <div class="lesson-header">
                        <input type="checkbox" class="lesson-checkbox" onchange="updateProgress()">
                        <div class="lesson-title">Distributed Tracing: Understanding Service Dependencies</div>
                        <a href="https://zq99299.github.io/note-architect/hc/05/05.html" class="lesson-link" target="_blank">ðŸ”— Original</a>
                    </div>
                    <div class="lesson-content">
                        <h3>Key Concepts:</h3>
                        <ul>
                            <li><strong>Trace Components:</strong> Spans, traces, baggage, sampling strategies</li>
                            <li><strong>Instrumentation:</strong> Automatic vs manual instrumentation, framework integration</li>
                            <li><strong>Sampling:</strong> Head-based sampling, tail-based sampling, adaptive sampling</li>
                            <li><strong>Analysis:</strong> Critical path analysis, dependency mapping, performance bottlenecks</li>
                        </ul>
                        <h3>Main Takeaways:</h3>
                        <ul>
                            <li>Distributed tracing is essential for debugging microservices</li>
                            <li>Implement consistent trace context propagation across services</li>
                            <li>Choose sampling strategy based on traffic volume and analysis needs</li>
                            <li>Use traces to identify performance bottlenecks and service dependencies</li>
                            <li>Consider storage and analysis costs when designing tracing systems</li>
                        </ul>
                        <h3>Interview Relevance:</h3>
                        <ul>
                            <li>Critical observability component for distributed systems</li>
                            <li>Shows understanding of debugging complex distributed interactions</li>
                            <li>Demonstrates operational maturity in microservices environments</li>
                        </ul>
                    </div>
                </div>

                <div class="lesson">
                    <div class="lesson-header">
                        <input type="checkbox" class="lesson-checkbox" onchange="updateProgress()">
                        <div class="lesson-title">Load Balancing: Traffic Distribution Strategies</div>
                        <a href="https://zq99299.github.io/note-architect/hc/05/06.html" class="lesson-link" target="_blank">ðŸ”— Original</a>
                    </div>
                    <div class="lesson-content">
                        <h3>Key Concepts:</h3>
                        <ul>
                            <li><strong>Load Balancing Algorithms:</strong> Round-robin, least connections, weighted, consistent hashing</li>
                            <li><strong>Health Checking:</strong> Active probes, passive monitoring, graceful degradation</li>
                            <li><strong>Session Affinity:</strong> Sticky sessions vs stateless design</li>
                            <li><strong>Global Load Balancing:</strong> DNS-based, anycast, geographic routing</li>
                        </ul>
                        <h3>Main Takeaways:</h3>
                        <ul>
                            <li>Choose algorithms based on traffic patterns and server characteristics</li>
                            <li>Implement comprehensive health checking to avoid routing failures</li>
                            <li>Design for stateless services to simplify load balancing</li>
                            <li>Consider connection draining during server maintenance</li>
                            <li>Monitor load distribution and adjust algorithms as needed</li>
                        </ul>
                        <h3>Interview Relevance:</h3>
                        <ul>
                            <li>Fundamental distributed systems component</li>
                            <li>Understanding of traffic distribution and failover strategies</li>
                            <li>Shows knowledge of performance optimization techniques</li>
                        </ul>
                    </div>
                </div>

                <div class="lesson">
                    <div class="lesson-header">
                        <input type="checkbox" class="lesson-checkbox" onchange="updateProgress()">
                        <div class="lesson-title">API Gateway: Centralized Request Management</div>
                        <a href="https://zq99299.github.io/note-architect/hc/05/07.html" class="lesson-link" target="_blank">ðŸ”— Original</a>
                    </div>
                    <div class="lesson-content">
                        <h3>Key Concepts:</h3>
                        <ul>
                            <li><strong>Gateway Functions:</strong> Request routing, protocol translation, authentication, rate limiting</li>
                            <li><strong>Cross-Cutting Concerns:</strong> Logging, monitoring, security, caching</li>
                            <li><strong>Backend for Frontend:</strong> Client-specific API aggregation</li>
                            <li><strong>Gateway Patterns:</strong> Edge gateway, internal gateway, per-team gateway</li>
                        </ul>
                        <h3>Main Takeaways:</h3>
                        <ul>
                            <li>API Gateway centralizes cross-cutting concerns and simplifies client interactions</li>
                            <li>Implement proper authentication, authorization, and rate limiting</li>
                            <li>Consider request/response transformation and protocol translation</li>
                            <li>Design for high availability - gateway is a critical path component</li>
                            <li>Balance centralization benefits with potential bottleneck risks</li>
                        </ul>
                        <h3>Interview Relevance:</h3>
                        <ul>
                            <li>Common microservices architecture pattern</li>
                            <li>Shows understanding of API management and security</li>
                            <li>Demonstrates knowledge of system integration patterns</li>
                        </ul>
                    </div>
                </div>

                <div class="lesson">
                    <div class="lesson-header">
                        <input type="checkbox" class="lesson-checkbox" onchange="updateProgress()">
                        <div class="lesson-title">Multi-Region Deployment: Global Service Distribution</div>
                        <a href="https://zq99299.github.io/note-architect/hc/05/08.html" class="lesson-link" target="_blank">ðŸ”— Original</a>
                    </div>
                    <div class="lesson-content">
                        <h3>Key Concepts:</h3>
                        <ul>
                            <li><strong>Deployment Patterns:</strong> Active-active, active-passive, multi-master</li>
                            <li><strong>Data Replication:</strong> Synchronous vs asynchronous, conflict resolution</li>
                            <li><strong>Traffic Routing:</strong> Geographic DNS, latency-based routing, failover</li>
                            <li><strong>Consistency Challenges:</strong> CAP theorem, eventual consistency, split-brain prevention</li>
                        </ul>
                        <h3>Main Takeaways:</h3>
                        <ul>
                            <li>Multi-region deployment improves latency and availability</li>
                            <li>Design for eventual consistency in global distributed systems</li>
                            <li>Implement robust conflict resolution for concurrent updates</li>
                            <li>Consider data sovereignty and compliance requirements</li>
                            <li>Plan for region failures and cross-region failover scenarios</li>
                        </ul>
                        <h3>Interview Relevance:</h3>
                        <ul>
                            <li>Global scale system design considerations</li>
                            <li>Understanding of distributed consistency challenges</li>
                            <li>Shows knowledge of disaster recovery and business continuity</li>
                        </ul>
                    </div>
                </div>

                <div class="lesson">
                    <div class="lesson-header">
                        <input type="checkbox" class="lesson-checkbox" onchange="updateProgress()">
                        <div class="lesson-title">Service Mesh: Infrastructure Layer for Microservices</div>
                        <a href="https://zq99299.github.io/note-architect/hc/05/09.html" class="lesson-link" target="_blank">ðŸ”— Original</a>
                    </div>
                    <div class="lesson-content">
                        <h3>Key Concepts:</h3>
                        <ul>
                            <li><strong>Service Mesh Architecture:</strong> Data plane (sidecar proxies), control plane (management)</li>
                            <li><strong>Traffic Management:</strong> Load balancing, routing, fault injection, canary deployments</li>
                            <li><strong>Security:</strong> mTLS, identity, policy enforcement</li>
                            <li><strong>Observability:</strong> Metrics collection, distributed tracing, access logs</li>
                        </ul>
                        <h3>Main Takeaways:</h3>
                        <ul>
                            <li>Service mesh provides infrastructure-level microservices capabilities</li>
                            <li>Separates business logic from infrastructure concerns (networking, security, observability)</li>
                            <li>Enables consistent policies across all services</li>
                            <li>Consider operational complexity and performance overhead</li>
                            <li>Evaluate whether mesh benefits justify additional complexity</li>
                        </ul>
                        <h3>Interview Relevance:</h3>
                        <ul>
                            <li>Advanced microservices infrastructure pattern</li>
                            <li>Shows understanding of separation of concerns</li>
                            <li>Demonstrates knowledge of modern service architecture trends</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>

        <!-- Section 6: Operations & Maintenance -->
        <div class="section" data-section="operations">
            <div class="section-header" onclick="toggleSection('operations')">
                <div>
                    <div class="section-title">06. Operations & Maintenance (7 lessons)</div>
                    <div class="section-meta">
                        <span>Monitoring â€¢ APM â€¢ Load Testing â€¢ Circuit Breakers â€¢ Rate Limiting</span>
                    </div>
                </div>
                <div class="expand-icon">â–¼</div>
            </div>
            <div class="section-content">
                <div class="lesson">
                    <div class="lesson-header">
                        <input type="checkbox" class="lesson-checkbox" onchange="updateProgress()">
                        <div class="lesson-title">System Monitoring: Observability in High-Traffic Systems</div>
                        <a href="https://zq99299.github.io/note-architect/hc/06/01.html" class="lesson-link" target="_blank">ðŸ”— Original</a>
                    </div>
                    <div class="lesson-content">
                        <h3>Key Concepts:</h3>
                        <ul>
                            <li><strong>Three Pillars:</strong> Metrics (quantitative data), Logs (event records), Traces (request flows)</li>
                            <li><strong>Monitoring Layers:</strong> Infrastructure, application, business metrics</li>
                            <li><strong>Alerting Strategies:</strong> Symptom-based vs cause-based alerts, alert fatigue prevention</li>
                            <li><strong>SLI/SLO/SLA:</strong> Service Level Indicators, Objectives, Agreements</li>
                        </ul>
                        <h3>Main Takeaways:</h3>
                        <ul>
                            <li>Monitor what matters to users: availability, performance, correctness</li>
                            <li>Implement multi-level monitoring: infrastructure â†’ application â†’ business</li>
                            <li>Design alerts for actionable symptoms, not low-level causes</li>
                            <li>Use SLOs to drive reliability decisions and error budgets</li>
                            <li>Invest in dashboards that tell a story about system health</li>
                            <li>Correlate metrics, logs, and traces for effective troubleshooting</li>
                        </ul>
                        <h3>Interview Relevance:</h3>
                        <ul>
                            <li>Essential operational maturity for production systems</li>
                            <li>Shows understanding of reliability engineering principles</li>
                            <li>Demonstrates data-driven approach to system health</li>
                        </ul>
                    </div>
                </div>

                <div class="lesson">
                    <div class="lesson-header">
                        <input type="checkbox" class="lesson-checkbox" onchange="updateProgress()">
                        <div class="lesson-title">Application Performance Monitoring (APM)</div>
                        <a href="https://zq99299.github.io/note-architect/hc/06/02.html" class="lesson-link" target="_blank">ðŸ”— Original</a>
                    </div>
                    <div class="lesson-content">
                        <h3>Key Concepts:</h3>
                        <ul>
                            <li><strong>APM Components:</strong> Real user monitoring (RUM), synthetic monitoring, server monitoring</li>
                            <li><strong>Performance Metrics:</strong> Response time, throughput, error rate, resource utilization</li>
                            <li><strong>Code Profiling:</strong> CPU profiling, memory analysis, database query optimization</li>
                            <li><strong>User Experience:</strong> Page load times, transaction completion, error tracking</li>
                        </ul>
                        <h3>Main Takeaways:</h3>
                        <ul>
                            <li>APM bridges infrastructure monitoring and business metrics</li>
                            <li>Focus on user-centric metrics: page load time, transaction success rate</li>
                            <li>Implement both proactive (synthetic) and reactive (RUM) monitoring</li>
                            <li>Use profiling to identify performance bottlenecks in code</li>
                            <li>Correlate performance issues with business impact</li>
                            <li>Set up automated performance regression detection</li>
                        </ul>
                        <h3>Interview Relevance:</h3>
                        <ul>
                            <li>Shows understanding of performance optimization lifecycle</li>
                            <li>Demonstrates user-centric system design approach</li>
                            <li>Important for maintaining system performance at scale</li>
                        </ul>
                    </div>
                </div>

                <div class="lesson">
                    <div class="lesson-header">
                        <input type="checkbox" class="lesson-checkbox" onchange="updateProgress()">
                        <div class="lesson-title">Load Testing: Validating System Performance Under Stress</div>
                        <a href="https://zq99299.github.io/note-architect/hc/06/03.html" class="lesson-link" target="_blank">ðŸ”— Original</a>
                    </div>
                    <div class="lesson-content">
                        <h3>Key Concepts:</h3>
                        <ul>
                            <li><strong>Testing Types:</strong> Load testing, stress testing, spike testing, volume testing</li>
                            <li><strong>Performance Modeling:</strong> Baseline performance, capacity planning, scalability limits</li>
                            <li><strong>Test Environment:</strong> Production-like data, realistic traffic patterns</li>
                            <li><strong>Bottleneck Identification:</strong> CPU, memory, I/O, network, database constraints</li>
                        </ul>
                        <h3>Main Takeaways:</h3>
                        <ul>
                            <li>Load test early and often to prevent production surprises</li>
                            <li>Design tests that reflect realistic user behavior patterns</li>
                            <li>Test beyond normal capacity to find breaking points</li>
                            <li>Use production-like data and environment characteristics</li>
                            <li>Identify and document system bottlenecks for capacity planning</li>
                            <li>Automate load testing as part of CI/CD pipeline</li>
                        </ul>
                        <h3>Interview Relevance:</h3>
                        <ul>
                            <li>Critical for validating scalability claims in system design</li>
                            <li>Shows proactive approach to performance validation</li>
                            <li>Demonstrates understanding of system limits and capacity planning</li>
                        </ul>
                    </div>
                </div>

                <div class="lesson">
                    <div class="lesson-header">
                        <input type="checkbox" class="lesson-checkbox" onchange="updateProgress()">
                        <div class="lesson-title">Configuration Management: Dynamic System Behavior Control</div>
                        <a href="https://zq99299.github.io/note-architect/hc/06/04.html" class="lesson-link" target="_blank">ðŸ”— Original</a>
                    </div>
                    <div class="lesson-content">
                        <h3>Key Concepts:</h3>
                        <ul>
                            <li><strong>Configuration Types:</strong> Application config, feature flags, infrastructure settings</li>
                            <li><strong>Dynamic Updates:</strong> Hot reloading, configuration push, polling mechanisms</li>
                            <li><strong>Configuration Validation:</strong> Schema validation, gradual rollout, rollback capabilities</li>
                            <li><strong>Security:</strong> Configuration encryption, access control, audit logging</li>
                        </ul>
                        <h3>Main Takeaways:</h3>
                        <ul>
                            <li>Externalize configuration to enable runtime behavior changes</li>
                            <li>Implement configuration validation to prevent invalid settings</li>
                            <li>Use gradual rollout for configuration changes to minimize risk</li>
                            <li>Provide quick rollback mechanisms for problematic changes</li>
                            <li>Secure sensitive configuration data with encryption and access controls</li>
                            <li>Log configuration changes for audit and debugging purposes</li>
                        </ul>
                        <h3>Interview Relevance:</h3>
                        <ul>
                            <li>Shows operational sophistication in system management</li>
                            <li>Demonstrates understanding of change management and risk mitigation</li>
                            <li>Important for feature deployment and system tuning</li>
                        </ul>
                    </div>
                </div>

                <div class="lesson">
                    <div class="lesson-header">
                        <input type="checkbox" class="lesson-checkbox" onchange="updateProgress()">
                        <div class="lesson-title">Circuit Breaker Pattern: Preventing Cascade Failures</div>
                        <a href="https://zq99299.github.io/note-architect/hc/06/05.html" class="lesson-link" target="_blank">ðŸ”— Original</a>
                    </div>
                    <div class="lesson-content">
                        <h3>Key Concepts:</h3>
                        <ul>
                            <li><strong>Circuit States:</strong> Closed (normal), Open (failing), Half-open (testing recovery)</li>
                            <li><strong>Failure Detection:</strong> Error thresholds, timeout tracking, health indicators</li>
                            <li><strong>Recovery Testing:</strong> Gradual traffic restoration, success rate monitoring</li>
                            <li><strong>Fallback Strategies:</strong> Default responses, cached data, degraded functionality</li>
                        </ul>
                        <h3>Main Takeaways:</h3>
                        <ul>
                            <li>Circuit breakers prevent cascade failures in distributed systems</li>
                            <li>Configure appropriate failure thresholds and timeout values</li>
                            <li>Implement meaningful fallback responses for better user experience</li>
                            <li>Monitor circuit breaker metrics: trip rate, recovery time, fallback usage</li>
                            <li>Test circuit breaker behavior with chaos engineering</li>
                            <li>Consider bulkhead pattern for resource isolation</li>
                        </ul>
                        <h3>Interview Relevance:</h3>
                        <ul>
                            <li>Essential resilience pattern for distributed systems</li>
                            <li>Shows understanding of failure handling and system stability</li>
                            <li>Demonstrates defensive programming principles</li>
                        </ul>
                    </div>
                </div>

                <div class="lesson">
                    <div class="lesson-header">
                        <input type="checkbox" class="lesson-checkbox" onchange="updateProgress()">
                        <div class="lesson-title">Rate Limiting: Protecting Services from Overload</div>
                        <a href="https://zq99299.github.io/note-architect/hc/06/06.html" class="lesson-link" target="_blank">ðŸ”— Original</a>
                    </div>
                    <div class="lesson-content">
                        <h3>Key Concepts:</h3>
                        <ul>
                            <li><strong>Rate Limiting Algorithms:</strong> Token bucket, leaky bucket, fixed/sliding window</li>
                            <li><strong>Scope and Granularity:</strong> Per-user, per-API, per-service, global limits</li>
                            <li><strong>Implementation Layers:</strong> API gateway, application layer, infrastructure level</li>
                            <li><strong>Response Strategies:</strong> Reject requests, queue requests, degrade functionality</li>
                        </ul>
                        <h3>Main Takeaways:</h3>
                        <ul>
                            <li>Rate limiting protects systems from abuse and overload</li>
                            <li>Choose algorithms based on traffic patterns and business requirements</li>
                            <li>Implement fair distribution of resources across users/services</li>
                            <li>Provide clear error messages and retry guidance when limits exceeded</li>
                            <li>Monitor rate limiting effectiveness and adjust limits based on usage patterns</li>
                            <li>Consider different strategies for different types of traffic</li>
                        </ul>
                        <h3>Interview Relevance:</h3>
                        <ul>
                            <li>Important protection mechanism for public APIs</li>
                            <li>Shows understanding of resource management and fair usage</li>
                            <li>Demonstrates knowledge of different algorithmic approaches</li>
                        </ul>
                    </div>
                </div>

                <div class="lesson">
                    <div class="lesson-header">
                        <input type="checkbox" class="lesson-checkbox" onchange="updateProgress()">
                        <div class="lesson-title">System Reliability Interview Preparation</div>
                        <a href="https://zq99299.github.io/note-architect/hc/06/07.html" class="lesson-link" target="_blank">ðŸ”— Original</a>
                    </div>
                    <div class="lesson-content">
                        <h3>Key Concepts:</h3>
                        <ul>
                            <li><strong>SRE Principles:</strong> Error budgets, toil reduction, blameless post-mortems</li>
                            <li><strong>Reliability Patterns:</strong> Graceful degradation, bulkhead isolation, timeouts</li>
                            <li><strong>Incident Response:</strong> On-call practices, escalation procedures, communication</li>
                            <li><strong>Capacity Planning:</strong> Growth projections, resource forecasting, cost optimization</li>
                        </ul>
                        <h3>Main Takeaways:</h3>
                        <ul>
                            <li>Reliability is a feature that must be designed and measured</li>
                            <li>Use error budgets to balance reliability with feature velocity</li>
                            <li>Implement comprehensive incident response and learning processes</li>
                            <li>Plan capacity based on growth patterns and business requirements</li>
                            <li>Automate operational tasks to reduce toil and human error</li>
                            <li>Foster a culture of reliability and continuous improvement</li>
                        </ul>
                        <h3>Interview Relevance:</h3>
                        <ul>
                            <li>Comprehensive understanding of operational excellence</li>
                            <li>Shows maturity in running production systems at scale</li>
                            <li>Demonstrates balance between reliability and business objectives</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>

        <!-- Section 7: Real-World Practice -->
        <div class="section" data-section="realworld">
            <div class="section-header" onclick="toggleSection('realworld')">
                <div>
                    <div class="section-title">07. Real-World Practice (4 lessons)</div>
                    <div class="section-meta">
                        <span>Counter Systems â€¢ Unread Counts â€¢ News Feed Architecture</span>
                    </div>
                </div>
                <div class="expand-icon">â–¼</div>
            </div>
            <div class="section-content">
                <div class="lesson">
                    <div class="lesson-header">
                        <input type="checkbox" class="lesson-checkbox" onchange="updateProgress()">
                        <div class="lesson-title">Counter System Design: Handling Trillion-Scale Social Media Metrics</div>
                        <a href="https://zq99299.github.io/note-architect/hc/07/01.html" class="lesson-link" target="_blank">ðŸ”— Original</a>
                    </div>
                    <div class="lesson-content">
                        <h3>Key Concepts:</h3>
                        <ul>
                            <li><strong>Scale Challenge:</strong> Trillions of counters (likes, shares, views) across billions of posts and users</li>
                            <li><strong>Access Patterns:</strong> Massive read traffic (millions QPS), high write concurrency on hot posts</li>
                            <li><strong>Storage Evolution:</strong> MySQL â†’ MySQL+Redis â†’ Pure Redis â†’ Custom Redis with memory optimization</li>
                            <li><strong>Memory Optimization:</strong> Custom data structures reducing storage from 70 bytes to 12 bytes per counter</li>
                        </ul>
                        <h3>Main Takeaways:</h3>
                        <ul>
                            <li>Start simple (MySQL) and evolve architecture based on actual bottlenecks</li>
                            <li>Pure Redis eliminates cache consistency issues but requires memory optimization</li>
                            <li>Message queues enable batch processing: combine multiple +1 operations into single +3</li>
                            <li>Custom storage formats: Long keys (8 bytes) vs string keys (28 bytes) - massive savings</li>
                            <li>Hot/cold data separation: Memory for recent data, SSD for historical with async loading</li>
                            <li>Hash-based storage with collision resolution for compact array-based storage</li>
                        </ul>
                        <h3>Interview Relevance:</h3>
                        <ul>
                            <li>Complete real-world system design case study</li>
                            <li>Shows evolution from simple to optimized architecture</li>
                            <li>Demonstrates memory optimization and cost management at scale</li>
                        </ul>
                    </div>
                </div>

                <div class="lesson">
                    <div class="lesson-header">
                        <input type="checkbox" class="lesson-checkbox" onchange="updateProgress()">
                        <div class="lesson-title">Unread Count System: Efficient Social Media Notification Tracking</div>
                        <a href="https://zq99299.github.io/note-architect/hc/07/02.html" class="lesson-link" target="_blank">ðŸ”— Original</a>
                    </div>
                    <div class="lesson-content">
                        <h3>Key Concepts:</h3>
                        <ul>
                            <li><strong>Unread Types:</strong> Messages, mentions, friend requests, activity notifications</li>
                            <li><strong>Consistency Requirements:</strong> Strong consistency for critical notifications, eventual for less critical</li>
                            <li><strong>Read Patterns:</strong> Frequent polling, real-time updates, batch operations</li>
                            <li><strong>Storage Strategy:</strong> Separate storage for different unread types based on access patterns</li>
                        </ul>
                        <h3>Main Takeaways:</h3>
                        <ul>
                            <li>Different unread types have different consistency and latency requirements</li>
                            <li>Use bitmap or compact counters for efficient unread tracking</li>
                            <li>Implement read receipts and acknowledgment patterns carefully</li>
                            <li>Consider push vs pull models for real-time unread updates</li>
                            <li>Handle edge cases: offline users, bulk mark-as-read, concurrent updates</li>
                            <li>Optimize for common operations: increment unread, batch clear, count query</li>
                        </ul>
                        <h3>Interview Relevance:</h3>
                        <ul>
                            <li>Common feature in social and messaging applications</li>
                            <li>Tests understanding of consistency vs performance trade-offs</li>
                            <li>Shows knowledge of real-time system design patterns</li>
                        </ul>
                    </div>
                </div>

                <div class="lesson">
                    <div class="lesson-header">
                        <input type="checkbox" class="lesson-checkbox" onchange="updateProgress()">
                        <div class="lesson-title">News Feed Architecture: Push vs Pull Models at Scale</div>
                        <a href="https://zq99299.github.io/note-architect/hc/07/03.html" class="lesson-link" target="_blank">ðŸ”— Original</a>
                    </div>
                    <div class="lesson-content">
                        <h3>Key Concepts:</h3>
                        <ul>
                            <li><strong>Push Model (Fan-out-on-write):</strong> Pre-compute feeds when content is published</li>
                            <li><strong>Pull Model (Fan-out-on-read):</strong> Compute feeds dynamically when user requests</li>
                            <li><strong>Hybrid Approach:</strong> Push for normal users, pull for celebrities, mixed strategies</li>
                            <li><strong>Ranking Algorithms:</strong> Chronological, engagement-based, ML-powered relevance</li>
                        </ul>
                        <h3>Main Takeaways:</h3>
                        <ul>
                            <li>Push model: faster reads, expensive writes (celebrity with millions of followers)</li>
                            <li>Pull model: faster writes, expensive reads (aggregating from thousands of followees)</li>
                            <li>Hybrid approach handles different user types optimally</li>
                            <li>Cache precomputed feeds with appropriate TTL and eviction policies</li>
                            <li>Handle real-time updates: new posts, engagement changes, relevance updates</li>
                            <li>Consider storage costs: push model requires massive storage for precomputed feeds</li>
                        </ul>
                        <h3>Interview Relevance:</h3>
                        <ul>
                            <li>Classic system design interview question (Twitter/Facebook feed)</li>
                            <li>Demonstrates understanding of read/write trade-offs</li>
                            <li>Shows ability to handle different user behavior patterns</li>
                        </ul>
                    </div>
                </div>

                <div class="lesson">
                    <div class="lesson-header">
                        <input type="checkbox" class="lesson-checkbox" onchange="updateProgress()">
                        <div class="lesson-title">System Design Synthesis: Putting It All Together</div>
                        <a href="https://zq99299.github.io/note-architect/hc/07/04.html" class="lesson-link" target="_blank">ðŸ”— Original</a>
                    </div>
                    <div class="lesson-content">
                        <h3>Key Concepts:</h3>
                        <ul>
                            <li><strong>Architecture Evolution:</strong> Monolith â†’ Service-oriented â†’ Microservices â†’ Serverless</li>
                            <li><strong>Technology Selection:</strong> Right tool for right job, considering team expertise and operational cost</li>
                            <li><strong>Trade-off Analysis:</strong> Performance vs complexity, consistency vs availability, cost vs features</li>
                            <li><strong>Future-Proofing:</strong> Extensibility, maintainability, team scalability</li>
                        </ul>
                        <h3>Main Takeaways:</h3>
                        <ul>
                            <li>System design is about making informed trade-offs, not finding perfect solutions</li>
                            <li>Start simple and evolve based on real constraints and requirements</li>
                            <li>Consider operational complexity and team capabilities in technology choices</li>
                            <li>Document assumptions and decision rationale for future reference</li>
                            <li>Plan for failure scenarios and have rollback strategies</li>
                            <li>Balance engineering excellence with business value delivery</li>
                        </ul>
                        <h3>Interview Relevance:</h3>
                        <ul>
                            <li>Demonstrates holistic thinking about system design</li>
                            <li>Shows maturity in balancing technical and business considerations</li>
                            <li>Synthesis of all concepts learned throughout the course</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>

        <div class="footer">
            <p>ðŸ™ <strong>Created by Aria</strong> - AI Assistant specializing in System Design and Architecture</p>
            <p>Original Chinese course: <a href="https://zq99299.github.io/note-architect/hc/" target="_blank" style="color: #667eea;">é«˜å¹¶å‘ç³»ç»Ÿè®¾è®¡ 40 é—®</a></p>
            <p>Progress automatically saved to localStorage â€¢ Mobile-optimized â€¢ Dark theme friendly</p>
        </div>
    </div>

    <script>
        // Progress tracking
        function updateProgress() {
            const checkboxes = document.querySelectorAll('.lesson-checkbox');
            const completed = Array.from(checkboxes).filter(cb => cb.checked).length;
            const total = checkboxes.length;
            const percentage = (completed / total) * 100;
            
            const progressFill = document.getElementById('progressFill');
            const progressText = document.getElementById('progressText');
            
            if (progressFill) progressFill.style.width = percentage + '%';
            if (progressText) progressText.textContent = `Progress: ${completed}/${total} lessons completed (${Math.round(percentage)}%)`;
            
            // Save progress to localStorage
            saveProgress();
        }

        // Section toggling
        function toggleSection(sectionName) {
            const section = document.querySelector(`[data-section="${sectionName}"]`);
            if (section) {
                section.classList.toggle('expanded');
                // Save expanded state
                saveExpandedState();
            }
        }

        // Save progress to localStorage
        function saveProgress() {
            const checkboxes = document.querySelectorAll('.lesson-checkbox');
            const progress = Array.from(checkboxes).map(cb => cb.checked);
            localStorage.setItem('hc-study-progress', JSON.stringify(progress));
        }

        // Load progress from localStorage
        function loadProgress() {
            const saved = localStorage.getItem('hc-study-progress');
            if (saved) {
                const progress = JSON.parse(saved);
                const checkboxes = document.querySelectorAll('.lesson-checkbox');
                checkboxes.forEach((cb, index) => {
                    if (progress[index]) {
                        cb.checked = true;
                    }
                });
                updateProgress();
            }
        }

        // Save expanded sections
        function saveExpandedState() {
            const sections = document.querySelectorAll('.section');
            const expanded = Array.from(sections).map(section => 
                section.classList.contains('expanded')
            );
            localStorage.setItem('hc-expanded-sections', JSON.stringify(expanded));
        }

        // Load expanded sections
        function loadExpandedState() {
            const saved = localStorage.getItem('hc-expanded-sections');
            if (saved) {
                const expanded = JSON.parse(saved);
                const sections = document.querySelectorAll('.section');
                sections.forEach((section, index) => {
                    if (expanded[index]) {
                        section.classList.add('expanded');
                    }
                });
            }
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            loadProgress();
            loadExpandedState();
            
            // Add click listeners to section headers
            const headers = document.querySelectorAll('.section-header');
            headers.forEach(header => {
                header.addEventListener('click', function(e) {
                    e.preventDefault();
                    const section = this.closest('.section');
                    if (section) {
                        const sectionName = section.getAttribute('data-section');
                        toggleSection(sectionName);
                    }
                });
            });

            // Initialize progress on first load
            updateProgress();
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            // Alt + number to toggle sections
            if (e.altKey && e.key >= '1' && e.key <= '7') {
                e.preventDefault();
                const sectionNames = ['fundamentals', 'database', 'caching', 'messagequeues', 'distributed', 'operations', 'realworld'];
                const sectionIndex = parseInt(e.key) - 1;
                if (sectionIndex < sectionNames.length) {
                    toggleSection(sectionNames[sectionIndex]);
                }
            }
        });
    </script>
</body>
</html>